#!/bin/bash

##########################################################################
# Script : kernel.SlackBuild
# Purpose: Natively build and package the Linux Kernel for Slackware ARM
# Author : Stuart Winter <mozes@slackware.com>
# Date...: 20-Sep-2005
##########################################################################
# Changelog
############
# 20-Sep-2005
#       * First version for Linux 2.6.13.1 on the StrongARM RiscPC
# 31-Dec-2005
#       * Linux 2.6.14.5
##########################################################################

##########################################################################
# Functions:
##########################################################################

# Record toolchain & other info for the build log:
slackbuildinfo

# Paths to skeleton port's source & real Slackware source tree:
export CWD=$PWD

# Temporary build locations:
export TMPBUILD=$TMP/build-$PKGNAM
export PKG=$TMP/package-$PKGNAM
# Delete & re-create temporary directories then cd into $TMPBUILD
mkpkgdirs

# Extract the kernel source:
echo -n "Extracting Kernel source... "
tar xf $CWD/sources/linux-*.tar.xz || exit 1
echo "done"
# Make the source tree dir name match $VERSION (useful for rc releases)
mv -fv linux-* linux-$VERSION
cd linux-* || exit 1
slackhousekeeping

# Install the appropriate Kernel config file:
install -vpm644 $CWD/configs/config-$SLKARCH .config

# Remove any hyphen from the EXTRAVERSION name.
sed -i '/EXTRAVERSION *=/s/-//g' Makefile

# Ensure that the Kernel version reported in the Makefile matches
# the version in the package name that we plan to use.
#
# If we're doing builds of RC kernels, we can ignore this check and assume we performed the
# necessary due dilligence.  Non-RC releases have no 'EXTRAVERSION' value set.
#
if ! echo "$VERSION" | egrep "rc|next" ; then
   if [ "$( echo "$(sed -ne's/^VERSION *= *//p' Makefile).$(sed -ne's/^PATCHLEVEL *= *//p' Makefile).$(sed -ne's/^SUBLEVEL *= *//p' Makefile)" )" != $VERSION ]; then
      echo "**** Package name vs Kernel version mismatch ****"
      echo "*** Slackware Packaging Version: $VERSION"
      echo "*** Kernel versions (From files): $( sed -ne's/^VERSION *= *//p' Makefile).$(sed -ne's/^PATCHLEVEL *= *//p' Makefile).$(sed -ne's/^SUBLEVEL *= *//p' Makefile )"
      exit 1
   fi
fi

echo "Kernel Slackware package version: $VERSION"

# Apply patches:
shopt -s extglob
for i in $CWD/sources/patches/!(*debian*)xz ; do
   auto_apply_patch $i || exit 1
done
shopt -u extglob
#tar xvvf $CWD/sources/patches/linux*debian*z
#for i in debian/patches/features/arm/* ; do
#   auto_apply_patch $i || exit 1
#done
#for i in debian/patches/bugfix/arm/* ; do
#   auto_apply_patch $i || exit 1
#done

# Build fix for compiling Tegra USB support as modules:
sed -i '/obj-$(CONFIG_USB_COMMON).*+= phy\// a\obj-$(CONFIG_USB_EHCI_TEGRA)   += phy\/' drivers/usb/Makefile || exit 1

# Build Kernel
make clean
echo "******************************"
echo "*** Building kernel zImage ***"
echo "******************************"
make $NUMJOBS CONFIG_DEBUG_SECTION_MISMATCH=y zImage || make CONFIG_DEBUG_SECTION_MISMATCH=y zImage || exit 1
# Build the U-Boot image for 'Das U-Boot' - required for ARM devices that use the U-Boot Linux Loader:
#if [ "$SLKARCH" = "armv7" ]; then
#   # Because we're building the ARMv7 kernel for multiple devices, the recommended route is to
#   # build 'zImage' only, and use mkimage to set the load address. The problem with this is that it
#   # this isn't realistic and upgrading u-Boot on your devices can lead to a bricked device.
#   # So I ran 'make -n uImage' on Linux 3.9 and took the value from there.
#   make LOADADDR=0x00008000 uImage || exit 1
# else
#   # ARMv5 targets are fine since we've stipulated only one architecture per kernel configuration:
#   make uImage || exit 1
#fi
# Since Linux 3.17, all archs require a load address:
echo "******************************"
echo "*** Building kernel uImage ***"
echo "******************************"
make $NUMJOBS LOADADDR=0x00008000 uImage || make LOADADDR=0x00008000 uImage || exit 1

# Build modules:
echo "************************"
echo "*** Building modules ***"
echo "************************"
make $NUMJOBS CONFIG_DEBUG_SECTION_MISMATCH=y modules || make CONFIG_DEBUG_SECTION_MISMATCH=y modules || exit 1

# Archive the compiled kernel source - this is used to create the kernel-source package.
# The reason why we check the architecture is because with the soft float port we had
# multiple kernels, but there was no need to have multiple Kernel sources.
# With the hard float and aarch64 port, we have just one Kernel; but in case we end up with
# more than one Kernel in the future, we'll keep this check in place.
# "slkarch" is the _package_ name architecture not the OS architecture - e.g. it'd be "armv5", "armv7", "aarch64"
if [[ "${SLKARCH}" =~ (armv7|aarch64) ]]; then
   echo "Archiving compiled source for kernel-source package..."
   # This takes far too long on ARM. I'll let the Distro polishing script pack this one:
   # ( cd .. && tar -Ixz -pcf $CWD/compiled-sources/$SLKARCH-kernel-$VERSION-compiled.tar.xz linux-$VERSION )
   ( cd .. && tar -pcf $CWD/compiled-sources/$SLKARCH-kernel-$VERSION-compiled.tar linux-$VERSION )
fi

# Archive the Kernel headers in order to build the d/kernel-headers package.
echo "Archiving the Kernel includes for d/kernel-headers..."
mkdir -vpm755 $TMPBUILD/kernel-headers
# Install 'sanitised' headers:
make INSTALL_HDR_PATH=$TMPBUILD/kernel-headers headers_install
( cd $TMPBUILD/kernel-headers
  # Wipe these '.install' and '..install.cmd' files
  find . -iname '.*' -type f -print0 | xargs -0 rm -f
  tar -Ixz -pcf $CWD/../d/kernel-headers/sources/$SLKARCH-kernel-headers-$VERSION.tar.xz . )

# Install modules into the package:
make modules_install INSTALL_MOD_PATH=$PKG || exit 1
rm -rf /lib/modules/$VERSION-$SLKARCH
# Needed for mkinitrd to find the modules:
make modules_install || exit 1

# Install & archive the firmware so it can be built from a separate script in
# a/kernel-firmware.  These firmware files are architecture independent so
# we only need one package.
#
# This isn't used any longer - the kernel-firmware package's firmware is extracted
# from the Slackware x86 source tree.  We'll leave it in, should I ever want to
# easily extract a piece of firmware from the kernel.org Kernel.
echo "Installing and archiving kernel-firmware for the a/kernel-firmware package ..."
mkdir -vpm755 $TMPBUILD/firmwareinstall
make firmware_install INSTALL_FW_PATH=$TMPBUILD/firmwareinstall/lib/firmware
cp -fav firmware/WHENCE $TMPBUILD/firmwareinstall/lib/firmware

# Install the modules into the a/kernel-modules source directory for use afterwards.
# (these are compressed by the kernel-modules.SlackBuild script)
echo "Archiving Kernel modules for the a/kernel-modules package..."
# Wipe the firmware from the package since it's included in the a/kernel-firmware package
# and delt with above:
echo "Wiping /lib/firmware from the current package contents so that"
echo "it won't be included in the a/kernel-modules package ..."
rm -rf $PKG/lib/firmware
( cd $PKG && tar -Ixz -pcf $CWD/../a/kernel-modules/sources/$SLKARCH-kernel-modules-$VERSION.tar.xz lib/ )

# When building in /patches/source:
#( cd $PKG && tar -Ixz -pcf $CWD/../kernel-modules/sources/$SLKARCH-kernel-modules-$VERSION.tar.xz lib/ )

# Compress kernel modules to reduce the size of the initrd.
echo "Compressing Kernel modules for $SLKARCH ..."
find /lib/modules/$VERSION-$SLKARCH -type f -name "*.ko" -exec gzip -9f {} \;
for i in $(find /lib/modules/$VERSION-$SLKARCH -type l -name "*.ko") ; do ln -vfs $( readlink $i ).gz $i.gz ; rm -fv $i ; done
# Usually we'd do this inside the resulting package but we need the modules
# to be up to date on the live system so that mkinitrd can grab what it needs:
( cd /
  echo "Updating module dependencies for $VERSION-$SLKARCH"
  find lib/modules -name $VERSION-$SLKARCH -type d -mindepth 1 -maxdepth 1 -printf "%f\n" | xargs -i depmod {} -b. )

# Install the kernel image and system map:
mkdir -vpm755 $PKG/{install,boot}
#gzip -f9cv System.map > $PKG/boot/System.map-$SLKARCH-$VERSION.gz
# These are named after their respective architectures so that you
# can have more than 1 Kernel package installed on the system
# at any one time, and configure your boot loader to boot, say
# "/uImage-", and not then have to maintain Kernel version
# numbers.
# We'll wipe the ones we don't need for this architecture a bit
# further down.
install -vpm644 System.map $PKG/boot/System.map-$SLKARCH-$VERSION
install -vpm644 arch/arm/boot/zImage $PKG/boot/zImage-$SLKARCH-$VERSION
install -vpm644 arch/arm/boot/uImage $PKG/boot/uImage-$SLKARCH-$VERSION
# Make symlinks:
( cd $PKG/boot
  ln -vfs System.map-$SLKARCH-$VERSION System.map-$SLKARCH
  ln -vfs zImage-$SLKARCH-$VERSION zImage-$SLKARCH
  ln -vfs uImage-$SLKARCH-$VERSION uImage-$SLKARCH )

# The Kernel config file used (following the Slackware standard):
install -pvm644 .config $PKG/boot/config-$SLKARCH-$VERSION

# The package description:
install -pvm644 $CWD/slack-descs/$SLKARCH-slack-desc $PKG/install/slack-desc
# The script to handle appending DTB files to systems that have the
# 'dtb=' kernel paramater specified:
# Not needed for hard float port since all of the U-Boot versions are new enough
# to handle loading a DTB, but we'll leave this in here and let it error out.
install -pvm644 $CWD/doinst.sh $PKG/install/

# Copy the Kernel into our tree's 'kernels' directory:
# If you want to keep these, move the old one out of the way first
# otherwise it gets clobbered.
mkdir -vpm755 $PKGSTORE/../kernels/$SLKARCH
install -vm644 arch/arm/boot/zImage $PKGSTORE/../kernels/$SLKARCH/zImage-$SLKARCH

# Some Archs won't need a U-Boot image, but we'll supply it anyway if we built it:
install -vm644 arch/arm/boot/uImage $PKGSTORE/../kernels/$SLKARCH/uImage-$SLKARCH

# This is really for the installer build script:
gzip -f9cv System.map  > $PKGSTORE/../kernels/$SLKARCH/System.map.gz

# And because Slackware includes the kernel config, let's do it too!
install -vpm644 .config $PKGSTORE/../kernels/$SLKARCH/config

# Install the Flattened Device Tree appender script for the armv5.
# Since about Linux 3.14, the main Kirkwood devices such as SheevaPlug must
# use FDT.  This is an issue since the U-Boot for these devices doesn't support it.
# Therefore we need to go with the 'appended' option.  The below script is used
# primarily to append the correct DTB to the uImage for the Slackware Installer,
# but it's also useful to keep a copy in /boot just in case.
# Note that the kernel post install 'doinst.sh' script determines which FDT blob
# is required by the Kernel parameters 'slkkernel=armv5' and 'dtb=<file.dtb>'
if [ $SLKARCH = "armv5" ]; then
   install -vpm755 $CWD/fdt-selector $PKG/boot/
   install -vpm755 $CWD/fdt-selector $PKGSTORE/../kernels/$SLKARCH/
fi

# Make an initrd for the architecture - using a clean
# extraction (otherwise mkinitrd uses /boot/initrd-tree which on
# the Slackware ARM dev boxes, could contain anything! ;-)
#
# Note: Using mkinitrd will create the '/rootfs' file inside the initrd
#       filesystem in line with what the devbox running this script has
#       as its root filesystem.  However, you can (and probably should!)
#       (I tend to use ext3 though, so you'll be ok if you use that too! ;-) )
#       specify the root filesystem type at boot time by appending
#
#       rootfs=ext4  or which ever filesystem you're using.
#
#       For QEMU, this is explained in the 'disk_launch' helper script
#       provided.  This 'rootfs=' is just a Kernel command line value
#       which is parsed by the initrd's '/init' script.
#
# This is work in progress and will probably need to be expanded for
# other architectures - as each arch will need a separate initrd anyway,
# otherwise they'll contain modules for all supported architectures
# as the installer does.
# Tip: when looking for what depends on what in the Kernel:
#      find /usr/src/linux-$VERSION/ -name Kconfig -exec grep -l ZLIB_ {} \;
rm -rf $TMPBUILD/initrd-tree
mkdir -vpm755 $TMPBUILD/initrd-tree
# Unpack the generic Slackware initial ram disk tree:
tar xf /usr/share/mkinitrd/initrd-tree.tar.gz -C $TMPBUILD/initrd-tree

#
#
# Filesystems & supporting libraries to include - these are the standard
# offered by the Slackware Installer:
# If we wanted ocfs2 (I originally thought Slackware supported it!)
# then we also need:
# ocfs2:configfs
#
# Note: If you were referred to this build script by some of the supporting
#       Slackware ARM documentation, please note that this list of filesystem
#       modules most likely far exceeds what is suggested by the
#       /usr/share/mkinitrd/mkinitrd_command_generator.sh script.
#       This is because the Slackware ARM initrd must be able to boot a newly
#       installed OS which could have been configured in a number of ways
#       (basically this means "what filesystems you used" ;-) ).
#       Also, I try to keep this list in sync with the modules required by the
#       Slackware installer.  All that is needed by your own initrd will be
#       enough to access the installes OS, and then load the rest of the Kernel
#       modules from there.
#       So, "DON'T PANIC!!"
#       'mkinitrd' figures out the module dependencies and includes those too, so
#       we don't need to specify all associated modules (although I do try to keep a
#       running list where possible).
#

   # Generic requirements:
   # Filesystems:
   INITRDFS="vfat:jbd:jbd2:nls:exportfs:binfmt_misc:md:dm-mod:mbcache:ext2:ext3:ext4:reiserfs:jfs:xfs:fscache"
   # Generic SCSI drivers & low-level drivers for discs/media:
   INITRDSCSI="sg:scsi_mod:sd_mod:cdrom:sr_mod:scsi_tgt"
   # Network filesystems:
   INITRDNETFS="nfs:lockd:nfs_common"
   # USB hubs & support mods, including interface devices (USB keyboards etc)
   # followed by some specific device drivers.
   INITRDUSB="ehci_orion:ehci-hcd:uhci_hcd:usbhid:ohci_hcd:hid:usbcore:usb-storage:ums-cypress:ums-usbat:ums-freecom:ums-isd200:ums-sddr09:ums-sddr55:ums-alauda:ums-jumpshot:ums-onetouch:ehci-platform:ehci-pci"
   # For SDHC/MMC cards:
   INITRDCARDS="mvsdio:mmci:mmc_block"
   # For NAND:
   # Removed for Linux 4.2 because it segfaults:
   # https://bugzilla.kernel.org/show_bug.cgi?id=111701
   #INITRDNAND="orion_nand"
   # XGI video chipset used on OpenRD and probably other kirkwood devices:
   # We'd also need "fbcon" if we choose not to compile it into the kernel.
   # The other bits in the list are the generic frame buffer drivers.
   INITRDVIDEO="ocfb:cfbcopyarea:cfbfillrect:cfbimgblt:xgifb"
   # Hacks.
   # See http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=608538
   # We need to add additional modules explicitly since modprobe won't show all dependencies
   # for 'xfs', for example.
   INITRDEXPLICITS="crc32c"

   # Real Time Clock (RTC):
   # Marvell (armv5 but probably used on others)
   # Trimslice: rtc-em3027
   # BananaPi: rtc-sunxi
   # Versatile Express: rtc-pl031
   # Allwinner: rtc_sun6i
   # Unknown: rtc_ds1307
   INITRDRTC="rtc-mv:rtc-em3027:rtc-sunxi:rtc-pl031:rtc-ds1307:rtc_sun6i:rtc_ds1307"

   # Additional stuff such as Netconsole (useful for debugging on machines without a serial cable)
   # INITRDADDITIONS=":netconsole"

case "$SLKARCH" in

  #########################################################################
  # Generic ARMv5 Kernel, including:-
  # Marvell Kirkwood series (Including the 'SheevaPlug' & OpenRD systems)
  #########################################################################
  armv5)

   # Network interface cards:
   INITRDNETDEV="mvmdio:mv643xx_eth"

   # SATA support for the Kirkwood family:
   # Generic libata & Marvell's SATA driver.
   INITRDSATA="libata:sata_mv"

   # Wait 4 seconds for the USB discs to spin up.  The SheevaPlug's
   # USB recognition can be a bit hit and miss, so it's best to
   # wait for longer than usual.
   mkinitrd \
      -R \
      -L \
      -u \
      -w 4 \
      -k $VERSION-$SLKARCH \
      -s $TMPBUILD/initrd-tree \
      -m $INITRDEXPLICITS:$INITRDVIDEO:$INITRDSCSI:$INITRDSATA:$INITRDUSB:$INITRDFS:$INITRDNETDEV:$INITRDNETFS:$INITRDCARDS${INITRDADDITIONS}:$INITRDRTC:$INITRDNAND \
      -o /initrd-$SLKARCH.gz
      # Creating it in "/" avoids an ugly bit of output at boot that contains
      # the path where it was built.  It just looks nicer this way :-)
   mv -fv /initrd-$SLKARCH.gz $TMPBUILD/
   # Incase the armv5 architectures ever need the standard gzip compressed CPIO format of OS initrd,
   # we'll include it.
   install -vpm644 $TMPBUILD/initrd-$SLKARCH.gz $PKGSTORE/../kernels/$SLKARCH/initrd-$SLKARCH

   # Create a uInitrd for U-boot:
   cd $TMPBUILD
   mkimage \
     -A arm \
     -O linux \
     -T ramdisk \
     -C gzip \
     -n "SlackARM for $SLKARCH platform" \
     -d $TMPBUILD/initrd-$SLKARCH.gz \
     $PKGSTORE/../kernels/$SLKARCH/uinitrd-$SLKARCH

   # Put a copy of the two initial RAM disk formats into the $PKG's /boot
   # This allows devices whose boot loader can read the partition where /boot resides
   # can have a generic initrd to boot into after installation.
   # This 'uinitrd' is for devices using the 'Das U-Boot' Linux loader.
   install -vpm644 $PKGSTORE/../kernels/$SLKARCH/uinitrd-$SLKARCH $PKG/boot/uinitrd-$SLKARCH-$VERSION
   # The gzipped compressed cpio version:
   install -vpm644 $PKGSTORE/../kernels/$SLKARCH/initrd-$SLKARCH $PKG/boot/initrd-$SLKARCH-$VERSION
   ( cd $PKG/boot
     ln -vfs uinitrd-$SLKARCH-$VERSION uinitrd-$SLKARCH
     ln -vfs initrd-$SLKARCH-$VERSION initrd-$SLKARCH )

   # Wipe what we don't need for this architecture.
   # In this case we only retain the 'uImage' and 'uInitrd'
   # In fact, now that FTD has been mandated for most boards, we might need the zImage
   # to hand to readily append the FDT blob and to make a new uImage from it.
   # ( cd $PKG/boot
   #   rm -fv zImage* initrd* )
   # rm -fv $PKGSTORE/../kernels/$SLKARCH/zImage*

  ;;

  #######################################################################
  # ARMv7 and greater systems
  #######################################################################

  armv7)

   # Network interface cards:
   # Versatile Express has SMSC911
   # Trimslice: Realtek 8169 (needs a firmware blob which is handled by the a/kernel-firmware package)
   # Banana Pi/stmmac - ST Microelectronics
   # USB (Mac) dongle
   INITRDNETDEV="smsc911x:r8169:stmmac:usbnet"

   # Generic libata:
   # The Compulab Trimslice's SATA is on an internal USB host
   INITRDSATA="libata"

   # Subsystems for System on Chip stuff:
   # (Some of these may not be required - I can most likely whittle them down later)
   # This is more of a catch all for various things.
   INITRDSOC="i2c-tegra:spi-tegra:dwmac-sunxi:sun6i_dma:i2c-ali1563"

   # Additional USB stuff:
   INITRDUSB="${INITRDUSB}:phy_sun4i_usb:ahci_sunxi:phy-tegra-usb:ehci_tegra"

   # For SDHC/MMC cards:
   INITRDCARDS="${INITRDCARDS}:sunxi-mmc"

   # Wait 4 seconds for the media to become available:
   mkinitrd \
      -R \
      -L \
      -u \
      -w 4 \
      -k $VERSION-$SLKARCH \
      -s $TMPBUILD/initrd-tree \
      -m $INITRDEXPLICITS:$INITRDSOC:$INITRDVIDEO:$INITRDSCSI:$INITRDSATA:$INITRDUSB:$INITRDFS:$INITRDNETDEV:$INITRDNETFS:$INITRDCARDS${INITRDADDITIONS}:$INITRDRTC:$INITRDNAND \
      -o /initrd-$SLKARCH.gz
   # Creating it in "/" avoids an ugly bit of output at boot that contains
   # the path where it was built.  It just looks nicer this way :-)
   mv -fv /initrd-$SLKARCH.gz $TMPBUILD/
   # Store the gzipped cpio version:
   install -vpm644 $TMPBUILD/initrd-$SLKARCH.gz $PKGSTORE/../kernels/$SLKARCH/initrd-$SLKARCH

   # Create a uInitrd for U-boot:
   cd $TMPBUILD
   mkimage \
     -A arm \
     -O linux \
     -T ramdisk \
     -C gzip \
     -n "SlackARM for the $SLKARCH platform" \
     -d $TMPBUILD/initrd-$SLKARCH.gz \
     $PKGSTORE/../kernels/$SLKARCH/uinitrd-$SLKARCH

   # Put a copy of the initial RAM disk into the $PKG's /boot
   # This allows devices whose boot loader can read the partition where /boot resides
   # can have a generic initrd to boot into after installation.
   # This 'uinitrd' is for devices using the 'Das U-Boot' Linux loader.
   install -vpm644 $PKGSTORE/../kernels/$SLKARCH/uinitrd-$SLKARCH $PKG/boot/uinitrd-$SLKARCH-$VERSION
   # The gzipped compressed cpio version is needed on machines such as the LeMaker Banan Pi
   # that use a version of U-Boot from 2014 that is able to boot these formats.
   install -vpm644 $PKGSTORE/../kernels/$SLKARCH/initrd-$SLKARCH $PKG/boot/initrd-$SLKARCH-$VERSION
   ( cd $PKG/boot
     ln -vfs uinitrd-$SLKARCH-$VERSION uinitrd-$SLKARCH
     ln -vfs initrd-$SLKARCH-$VERSION initrd-$SLKARCH )

   # Wipe what we don't need for this architecture.
   # In this case we only retain the 'uImage' and 'uInitrd'
   #( cd $PKG/boot
   #  #rm -fv zImage* initrd* ) ## we want the zImage for QEMU, but QEMU _can_ decode initrd's with a u-Boot header.
   #  rm -fv initrd* )

  ;;

esac

# It's nice to have this final touch (pun intended):
( cd $PKGSTORE/../kernels/$SLKARCH/
  touch -r ?Image-$SLKARCH * $PKG/boot/* )

# Compile the Device Tree Source (DTS) files into Device Tree Blobs (DTB):
# This file is for the 'Flattened Device Tree' technology.
# For the generic 'armv7' kernels, we have no way of knowing which DTB file
# the user will require, so we have to ship them all for each architecture.
#
mkdir -vpm755 $PKG/{install,boot/dtb-$VERSION}
( cd $PKG/boot && ln -vfs dtb-$VERSION dtb )

# Ensure that we're in the correct directory to build the DTB files.
cd $TMPBUILD/linux-$VERSION && make dtbs || exit 1
# Copy the extra ones that are not yet in the mainline kernel.  These are only for
# armv7:
if [ "$SLKARCH" = "armv7" ]; then
  echo "Adding extra DTBs from $CWD/sources/extra-dtb/ (if any exist)"
  cp -fav $CWD/sources/extra-dtb/*.dtb $TMPBUILD/linux-$VERSION/arch/arm/boot/dts/
fi
# Install DTB's into the package:
install -vpm644 $TMPBUILD/linux-$VERSION/arch/arm/boot/dts/*.dtb $PKG/boot/dtb-$VERSION/
# Install copies into the 'kernels' directory so that they can be easily
# available for tftp booting:
# We don't version the DTB files inside the '/kernels' directory because
# the kernel + initrd files are not versioned here since this dir is not
# packaged/version managed.
rm -rf $PKGSTORE/../kernels/$SLKARCH/dtb
mkdir -vpm755 $PKGSTORE/../kernels/$SLKARCH/dtb
install -vpm644 -oroot -groot $PKG/boot/dtb-$VERSION/* $PKGSTORE/../kernels/$SLKARCH/dtb/

# Build the base Kernel package (without libraries):
cd $PKG
chown -R root:root .
chmod -R og-w .
# Move the libs out of the way -- they go in a/kernel-modules package
# mv lib /tmp/$$lib
rm -rf lib # don't need these anymore since they are archived in the a/kernel-modules source directory

# Replace version number with a _ so it doesn't get confused with
# the package name.
# This is incase we're using any '-rc' releases.
export VERSION="$( echo $VERSION | sed 's?-??g' )"
# We need to pre-pend the symlink code to the main 'doinst.sh' since it requires the
# versionless symlinks when working on the FDT stuff.
makepkg -p -l y -c n $PKGSTORE/$PKGSERIES/$PKGNAM-$VERSION-$ARCH-$BUILD.txz

#EOF
