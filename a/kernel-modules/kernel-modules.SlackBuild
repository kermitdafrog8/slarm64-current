#!/bin/bash

##########################################################################
# Script : kernel-modules.SlackBuild
# Purpose: Create a Slackware a/kernel-modules package
# Author : Stuart Winter <mozes@slackware.com>
# Date...: 20-Sep-2005
##########################################################################
# Changelog
############
# 20-Sep-2005 - v1.00
#       * First version for Linux 2.6.13.1
# 29-Mar-2009 - v1.01
#       * Revised to create separate module packages for each supported
#         architecture.
##########################################################################
# Caveats:
#  - You build all Kernel module packages for all archs.  It's just easier
#    to script this way.  Usually each kernel is settled by the time it's
#    released, so when a kernel update is performed, it's for all archs
#    anyway.

# Record toolchain & other info for the build log:
slackbuildinfo

# Paths to skeleton port's source & real Slackware source tree:
# The kernel-modules stuff is part of the 'k' source directory rather than
# in the 'a' series:
#export CWD=$SLACKSOURCE/k/packaging-x86_64/kernel-modules/
export PORTCWD=$PWD

# Temporary build locations:
export TMPBUILD=$TMP/build-$PKGNAM

# Determine which kernel modules we have for this $VERSION of the Kernel
# and get building packages!
find $PORTCWD/sources \
  -type f \
  -mindepth 1 \
  -maxdepth 1 \
  -name "*-kernel*${VERSION}*.xz" \
  -printf "%f\n" | sort | cut -d- -f1 | uniq | while read ARCHTYPE ; do

  export PKG=$TMP/package-${PKGNAM}_$ARCHTYPE
  mkpkgdirs # Delete & re-create temporary directories then cd into $TMPBUILD
  cd $PKG # Enter into the package directory for this architecture

   # Place the Kernel modules into the package for this particular
   # architecture:
   tar xvvf $PORTCWD/sources/$ARCHTYPE-kernel-modules-$VERSION.tar.xz -C.

   # Compress Kernel modules.  Helps conserve disk space on the
   # embedded devices with small on-board storage:
   find ./lib/modules -type f -name "*.ko" -exec gzip -9f {} \;
   for i in $(find ./lib/modules -type l -name "*.ko") ; do ln -vfs $( readlink $i ).gz $i.gz ; rm -fv $i ; done

   # Install the package description:
   install -D -vpm644 $PORTCWD/slack-descs/$ARCHTYPE install/slack-desc

   # Install the post install script.
   # This is taken from Slackware's kernel-modules.SlackBuild script:
   cat << EOF > $PKG/install/doinst.sh
# A good idea whenever kernel modules are added or changed:
if [ -x sbin/depmod ]; then
  chroot . /sbin/depmod -a ${KERNELRELEASE} 1> /dev/null 2> /dev/null
fi

EOF

   # This is a symlink to where the kernel was compiled
   # We wipe these and create new ones pointing to /usr/src
   # (our kernels were compiled in a temporary location, so the symlink would be broken)
   #
   ( cd $PKG
     #find . -type l -name source -print0 | xargs -0 rm -f
     #find . -type l -name build  -print0 | xargs -0 rm -f
     cd lib/modules/*
     # If you install the kernel source package, these symlinks will work:
     #ln -vfs ../../../usr/src/$( find . -name source -printf "%l\n" | rev | cut -d/ -f1 | rev ) source
     #ln -vfs ../../../usr/src/$( find . -name build -printf "%l\n" | rev | cut -d/ -f1 | rev ) build
     # if ln -f worked, we could do the above but since it doesn't wipe the existing
     # symlink, we'll do this:
     LINKLOC=$( find . -name source -printf "%l\n" | rev | cut -d/ -f1 | rev )
     rm -rf source
     ln -vfs ../../../usr/src/$LINKLOC source
     LINKLOC=$( find . -name build -printf "%l\n" | rev | cut -d/ -f1 | rev )
     rm -rf build
     ln -vfs ../../../usr/src/$LINKLOC build
)

   # Update the dependencies list:
   # depmod -b $PKG $VERSION
   # Generate modules.dep files for each ARM architecture we have inside lib/modules
   # (which is only 1 for each individual .t?z, but this is legacy from the all-in-one script
   # and works properly):
   ( cd $PKG
     find lib/modules -type d -mindepth 1 -maxdepth 1 -printf "%f\n" | xargs -i depmod {} -b. )

   # If necessary, start the fakeroot server so we can set file/dir ownerships:
   start_fakeroot

   # Apply some of the generic Slackware packaging policies:
   cd $PKG
   slackslack      # chown -R root:root, chmod -R og-w, slackchown, slack644docs

   # Create the package in a subshell so that if we are adjusting the VERSION
   # (removing the "-") for the package name, then it doesn't affect the next
   # pass of this code; otherwise if we're building modules package for >1
   # architecture, it fails to match the version string to the filename.
   ( # Replace version number with a so it doesn't get confused with
     # the package name.
     # This is incase we're using any '-rc' releases.
     export VERSION="$( echo $VERSION | sed 's?-??g' )"

     # Set the package name to the particular architecture we're currently processing:
     # I don't know why I had this - it makes no sense to have a package named "kernel-modules-kirkwood-2.6.38.2_kirkwood-arm-2.t?z"
     # export SLACKPACKAGE=$PKGNAM-$ARCHTYPE-${VERSION}-$PKGARCH-$BUILD.t?z
     # I do now, this matches the naming scheme for Slackware x86's "smp" kernel package.
     # Even though the package name is different thus indeed creates a separate package,
     # it breaks the installer build script and since the x86 package will remain with the
     # same naming convention, it makes no sense to break it all here!
     export SLACKPACKAGE=$PKGNAM-$ARCHTYPE-${VERSION}_${ARCHTYPE}-$PKGARCH-$BUILD.txz
     # run makepkg -l y -c n
     slackmp )

   # Perform any final checks on the package:
   cd $PKG
   slackhlinks     # search for any hard links

# Finished with this arch, on to the next!
done

#EOF
