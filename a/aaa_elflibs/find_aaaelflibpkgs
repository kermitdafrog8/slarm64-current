#!/bin/bash
##############################################################################
# Program: find_aaaelflibpkgs
# Purpose: Find contents of Slackware's a/aaa_elflibs package
# Author : Stuart Winter <mozes@slackware.com> with the Perl one-liner
#          by Jim Hawkins
# Date...: 28-Aug-2006
# Version: 1.00
##############################################################################
# You can run this natively on Slackware ARM but beware that it'll take
# the best part of an hour! (when compiling KDE 
# simultaneously, anyway ;-) )
# Run it on an x86, and then run the build script on Slackware ARM.
# That's why this is a separate script.
#
# Usage: ./find_aaaelflibpkgs
# 
# This script will output a file in the $CWD named:
#   'x86_slackware_aaa_elflibs_pkg_list.txt'
# which is used by aaa_elflibs.SlackBuild.
#
##############################################################################

CWD=$( pwd )

# Drag in the Slackware ARM build kit: we use the config in here to 
# find out where our real x86 Slackware tree is:
if [ ! -f /usr/share/slackdev/buildkit.sh ]; then
   echo "You need to install and configure the slackkit package."
   exit 1
 else
   source /usr/share/slackdev/buildkit.sh
fi

# The Slackware x86 trees are at the same level as the Slackware ARM directories:
SLACKSOURCE=$PWD/../../../../slackware64-current/

echo "Slackware source tree: $SLACKSOURCE"

# Make a temporary extraction directory in which we'll explode Slackware's
# aaa_elflibs package:
TMP=/tmp/aaa-elfdingy
rm -rf $TMP
mkdir -pm755 $TMP

# Unpack the Slackware manifest file - helps speedup the search:
MANIFEST=$TMP/MANIFEST
bzcat $SLACKSOURCE/slackware*/MANIFEST.bz2 > $MANIFEST

# Extract the Slackware aaa_elflibs package so that we can determine its contents:
cd $TMP
tar xvvf $SLACKSOURCE/slackware*/a/aaa_elflibs*.t?z
# We want know about the symlinks too -- most are versionless symlinks
# but there may also be some manually added ones -- we'll check these
# later when we manually check over our port's resulting .t?z package:
sh install/doinst.sh

# Find all executable files:
( find . -name '*.so*' -type f -printf "%P\n" | xargs -i file '{}' | egrep '(ELF.*shared.)' | awk -F: '{print $1}' > $TMP/execfiles

# Store the symlinks for later perusal:
# Don't need this -- we take the symlinks from the port's packages install/doinst.sh
#  find . -type l -printf "%h/%l --> %P\n" > $CWD/x86_slackware_aaa_elflibs_symlinks.txt

# Determine which library files belong to which packages:
( cat $TMP/execfiles | while read lib; do 
      cat $MANIFEST | \
      perl -e'while (<STDIN>){$p=$1 if/Package: (.*\.t.z)/; print "$p:$ARGV[0]\n" if/\Q$ARGV[0]\E/}' $lib | sed 's?lib64?lib?'
    done ) | sort | uniq | sed 's?lib64?lib?'
) > $TMP/lib_to_pkglist

# Determine which packages contain each library - excluding aaa_elflibs since we are building
# that package, obviously we can't look in there for the libraries!
# We'll also ignore the -solibs packages and we'll choose the primary package:
egrep -v -- "aaa_elflibs|-solibs-" $TMP/lib_to_pkglist > $CWD/x86_slackware_aaa_elflibs_pkg_list.txt

# Determine which library files are *only* provided by aaa_elflibs and no longer exist
# within packages (one of the purposes of aaa_elflibs is to host older copies of libraries to
# aid in upgrades).  These are the ones we'll need to pull from our archive stash.
cut -d: -f2- $TMP/lib_to_pkglist | sort | uniq -u > $CWD/x86_slackware_aaa_elflibs_onlyhost_list.txt

# Now we know which libs are _in_ aaa_elflibs, we need to know which are *only* in aaa_elflibs
#{ awk -F: '{print $2}' x86_slackware_aaa_elflibs_pkg_list.txt ; cat x86_slackware_aaa_elflibs_onlyhost_list.txt ;} | sort | uniq


# Clean up:
#rm -rf $TMP
