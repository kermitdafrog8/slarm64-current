#!/bin/bash

# KDE.SlackBuild
# Heavily based on the original Slackware build scripts,
# Modified by Stuart Winter for Slackware ARM.
#
# Copyright 2011, 2012  Patrick J. Volkerding, Sebeka, MN, USA
# All rights reserved.
#
# Redistribution and use of this script, with or without modification, is
# permitted provided that the following conditions are met:
#
# 1. Redistributions of this script must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#
#  THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
#  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
#  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO
#  EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
#  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
#  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
#  OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
#  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
#  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
#  ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#
# Adapted by Eric Hameleers <alien@slackware.com> from the modular x.org build.

# Record toolchain & other info for the build log:
slackbuildinfo

# Paths to skeleton port's source & real Slackware source tree:
export CWD=$SLACKSOURCE/kde/
export PORTCWD=$PWD

# Temporary build locations:
export TMPBUILD=$TMP/build-$PKGNAM
export PKG=$TMPBUILD/package-$PKGNAM
mkpkgdirs # Delete & re-create temporary directories then cd into $TMPBUILDBUILD

CLEANUP=${CLEANUP:-"yes"} # clean up build directory after successful build.
CHECKOUT=${CHECKOUT:-"no"} # don't let the script checkout missing sources.

####################### Functions #####################################################

function short_package_name () {
  local PACKAGENAME="$( echo $1 | rev | cut -d- -f4- | rev )"
  echo ${PACKAGENAME}
}

pkgbase() {
  PKGEXT=$(echo $1 | rev | cut -f 1 -d . | rev)
  case $PKGEXT in
  'gz' )
    PKGRETURN=$(basename $1 .tar.gz)
    ;;
  'bz2' )
    PKGRETURN=$(basename $1 .tar.bz2)
    ;;
  'lzma' )
    PKGRETURN=$(basename $1 .tar.lzma)
    ;;
  'xz' )
    PKGRETURN=$(basename $1 .tar.xz)
    ;;
  *)
    PKGRETURN=$(basename $1)
    ;;
  esac
  echo $PKGRETURN
}

no_usr_share_doc() {
  # If there are docs, move them:
  if [ -d usr/share/doc ]; then
    mkdir -p usr/doc
    mv usr/share/doc/* usr/doc
    rmdir usr/share/doc
  fi
}

# If the build failed, let's restore the previous pkg build details:
fail_restore_buildnumber() {
  if [ -f "$PORTCWD/build-nums/${PKGNAME}.orig" ]; then
     echo "*** Build failed: Restoring previous build version ***"
     mv -fv $PORTCWD/build-nums/${PKGNAME}.orig $PORTCWD/build-nums/${PKGNAME}
     cat $PORTCWD/build-nums/${PKGNAME}
  fi
  # Bailout of KDE.SlackBuild:
  exit 1
}

# Support function builds one complete module (like 'kdelibs'), or
# exactly one package which is part of a module (like 'okular'):
build_mod_pkg () {
  kde_module=$1
  kde_pkg=$2

  cd $CWD/modules

  # See if $kde_module is a module name like "kdeadmin":
  if [ ! -z "$kde_module" ]; then
    if [ ! -f "$kde_module" ]; then
      return
    fi
  fi
  PKG=${SLACK_KDE_BUILD_DIR}/${kde_module}/package-${kde_module}
  rm -rf $PKG
  mkdir -p $PKG
  ( for PKGNAME in $(cat $kde_module |grep -v "^$" |grep -v "^#") ; do

     # Location for archives should always initially start in the x86 tree:
     LOCATIONCWD=$CWD

     echo "PKGNAME: $PKGNAME"
     echo "KDE module: $kde_module"


     # Ensure that the package isn't in Slackware ARM's local blacklist:
     if grep -wq "^$PKGNAME" $PORTCWD/slackwarearm-build-blacklist; then
        echo "**** $PKGNAME found in Slackware ARM local blacklist *****"
        echo "**** Not building this package *****"
        continue
     fi
#      else
#        echo "Package *"${PKGNAME}"* is not in the local Slackware ARM blacklist"

      #=========================== Slackware ARM modification ===========================
      # Now, if there's a local Slackware ARM version (which may be an alternate
      # version if the one in Slackware won't build), let's find it:
      # (this is very rare - which is why the logic of this bit of
      # code is awful; a real hack).
      if [ ! -z "$( basename $(find $PORTCWD/src -name "$PKGNAME-*.tar.?z*" |grep -E "$PKGNAME-[^-]+.tar.*$|$PKGNAME-[0-9].+.tar.*$") 2>/dev/null )" ]; then
         echo "******************************************************"
         echo "*** Found local copy $( find $PORTCWD/src -name "$PKGNAME-*.tar.?z*" |grep -E "$PKGNAME-[^-]+.tar.*$|$PKGNAME-[0-9].+.tar.*$") 2>/dev/null ) ****"
         echo "******************************************************"
         # We're using 'find' to locate the source archive, but we need to know whether
         # to look inside the Slackware x86 tree or the Slackware ARM 'overlay' tree:
         LOCATIONCWD=$PORTCWD
         echo "*** Using local port's source location: $LOCATIONCWD ****"
       else
         #echo "*** Using Slackware x86 source location: $CWD ***"
         LOCATIONCWD=$CWD
      fi
      #===================================================================================#

      # Find the full source filename - yeah ugly, but I had two goals:
      # 1- source tarball can be in a random subdirectory of src/
      # 2- differentiate between e.g. 'kdepim' and 'kdepim-runtime'

      # === Slackware ARM modification ===
      # Look in the 'location cwd' as we might have a different version than in Slackware x86 - otherwise
      # we'd use the version number from x86 and try and unpack a different version from the local port's source directory:
      kde_src=$(basename $(find $LOCATIONCWD/src -name "$PKGNAME-*.tar.?z*" |grep -E "$PKGNAME-[^-]+.tar.*$|$PKGNAME-[0-9].+.tar.*$") 2>/dev/null)
#      kde_src=$(basename $(find $CWD/src -name "$PKGNAME-*.tar.?z*" |grep -E "$PKGNAME-[^-]+.tar.*$|$PKGNAME-[0-9].+.tar.*$") 2>/dev/null)
      if [ "x$kde_src" = "x" ]; then
        echo "** Did not find '$PKGNAME' in $LOCATIONCWD/src (may not be an actual error - especially if we're using the Slackware ARM port's src location)"
        continue
      fi
      # Reset $PKGARCH to its initial value:
      PKGARCH=$ARCH
      # Perhaps $PKGARCH should be something different:
      if grep -wq "^$PKGNAME" ${CWD}/noarch ; then
        PKGARCH=noarch
      fi
      if grep -wq "^$PKGNAME" ${CWD}/package-blacklist ; then
        continue
      fi
      cd $SLACK_KDE_BUILD_DIR/${kde_module}
      # If $kde_pkg is set, we only want to build one package:
      if [ ! -z "$kde_pkg" ]; then
        if [ "$kde_pkg" = "$PKGNAME" ]; then
          # Set $PKG to a private dir for the modular package build:
          PKG=$SLACK_KDE_BUILD_DIR/${kde_module}/package-$PKGNAME
          rm -rf $PKG
          mkdir -p $PKG
        else
          continue
        fi
      else
        echo
        echo "Building from source ${kde_src}"
        echo
      fi
      if grep -wq "^$PKGNAME" ${CWD}/modularize ; then
        # Set $PKG to a private dir for the modular package build:
        PKG=$SLACK_KDE_BUILD_DIR/${kde_module}/package-$PKGNAME
        rm -rf $PKG
        mkdir -p $PKG
      fi

      # Let's figure out the version number on the modular package:
      MODULAR_PACKAGE_VERSION=$(echo $kde_src | rev | cut -f 3- -d . | cut -f 1 -d - | rev)

      echo "Package build details:"
      echo "Package: ${kde_src}"
      echo "Modular package version: $MODULAR_PACKAGE_VERSION"
      echo "Source location: $LOCATIONCWD"

      rm -rf $(pkgbase $kde_src)
#      tar xf $(find $CWD/src -name ${kde_src}) || exit 1
echo      "tar xf $(find ${LOCATIONCWD}/src -name ${kde_src})"
      tar xf $( find ${LOCATIONCWD}/src -name ${kde_src} ) || exit 1
      cd $(pkgbase $kde_src) || exit 1
      slackhousekeeping

      #=========================== Slackware ARM modification ===========================
      # Determine whether the version of this particular modular package
      # is the same as the last version we built.  If it isn't then
      # we reset the BUILD to 1, regardless of whether the indibuild script
      # was specified as a rebuild or upgrade.
      # This allows us to run this x11.SlackBuild to do mass updates (say with a new X release)
      # without having to manually keep track of what is new and what is
      # just a rebuild.
      #
      if [ -r $PORTCWD/build-nums/${PKGNAME} ]; then

         # Store the previous version so that we can revert, should the build fail.
         # Otherwise what happens is that the build number is incrememented until we have
         # a successful build:
         echo "*** Storing existing build and version information ***"
         cp -fav $PORTCWD/build-nums/${PKGNAME}{,.orig}

         source $PORTCWD/build-nums/${PKGNAME}
         # We found the previous details:
         echo "Package: $PKGNAME"
         echo "Previous built version: ${_PKGVER}"
         echo "Previous build #: $MODBUILD"
         echo "New version: $MODULAR_PACKAGE_VERSION"

         # _PKGVER is stored inside the package file name and indicates
         # the last build that was done.
         # The "indibuild" script sets just the build number to 1 when Upgrading
         # packages, so the logic below isn't useful if you're using that script.
         if [ "$MODULAR_PACKAGE_VERSION" != "$_PKGVER" -o -z "$_PKGVER" ]; then
            # Version doesn't match (let's assume it's an upgrade)
            # or the version string is empty.  Store new details:
            echo "*** Detected version change (or no previous version) for $PKGNAME ***"
            echo "*** Storing new version & setting BUILD to 1 ***"
            echo "_PKGVER=$MODULAR_PACKAGE_VERSION" > $PORTCWD/build-nums/${PKGNAME}
            echo "MODBUILD=1" >> $PORTCWD/build-nums/${PKGNAME}
         else
           # The version matched, so increment the BUILD *unless* the "indibuild" script
           # has set MODBUILDNOBUMP (which is used when we're rebuilding packages
           # to test fixes and so on prior to a public tree push -- otherwise by now
           # the public tree would be into the hundred build numbers ;-) ).
           echo "_PKGVER=$MODULAR_PACKAGE_VERSION" > $PORTCWD/build-nums/${PKGNAME}
            if [ -z "$MODBUILDNOBUMP" ]; then
               let MODBUILD++
               echo "*** Incrementing the BUILD number to $MODBUILD ***"
              else
               echo "*** Not incrementing build number (MODBUILDNOBUMP is set) ***"
               echo "*** (could also be because the indibuild script is being used) ***"
            fi
            echo "MODBUILD=$MODBUILD" >> $PORTCWD/build-nums/${PKGNAME}
        fi
       else
         # No build information found for this modular package so we'll
         # create it ready for next time.
         echo "*** No previous build information found: storing current version and build ***"
         echo "_PKGVER=$MODULAR_PACKAGE_VERSION" > $PORTCWD/build-nums/${PKGNAME}
         echo "MODBUILD=1" >> $PORTCWD/build-nums/${PKGNAME}
      fi
      #===================================================================================#

      # If any patches are needed, call this script to apply them:
      if [ -r $CWD/patch/${PKGNAME}.patch ]; then
        . $CWD/patch/${PKGNAME}.patch || exit 1
      fi
      # And then any Slackware ARM local Slackware ARM patches:
      if [ -r $PORTCWD/patch/${PKGNAME}.patch ]; then
        . $PORTCWD/patch/${PKGNAME}.patch
      fi

      # If there's any pre-install things to do, do them:
      if [ -r $CWD/pre-install/${PKGNAME}.pre-install ]; then
        . $CWD/pre-install/${PKGNAME}.pre-install
      fi

      # If there's any Slackware ARM local pre-install things to do, do them:
      if [ -r $PORTCWD/pre-install/${PKGNAME}.pre-install ]; then
        . $PORTCWD/pre-install/${PKGNAME}.pre-install
      fi

      # Run cmake, using custom cmake script if needed:
      # Slackware ARM local scripts take presidence over those in the Slackware x86 tree:
      if [ -r $PORTCWD/cmake/${PKGNAME} ]; then
         echo "*** Cmake configuration script: $PORTCWD/cmake/${PKGNAME}"
         . $PORTCWD/cmake/${PKGNAME}
      # If no Slackware ARM copy found, we'll use the x86 tree versions:
       elif [ -r $CWD/cmake/${PKGNAME} ]; then
         echo "*** Cmake configuration script: $CWD/cmake/${PKGNAME}"
         . $CWD/cmake/${PKGNAME}
       elif [ -r $CWD/cmake/${kde_module} ]; then
         echo "*** Cmake configuration script: $CWD/cmake/${kde_module}"
         . $CWD/cmake/${kde_module}
       else
        # This is the default configure script:
         echo "*** Cmake configuration script: default script $CWD/cmake/cmake"
        . $CWD/cmake/cmake
      fi

      # Build:  If we fail, we'll restore the previous build number
      #         so that the build# doesn't get out of control
      make $NUMJOBS || make || fail_restore_buildnumber

      # Install into the package:
      make install DESTDIR=$PKG || fail_restore_buildnumber

      # Looks like the build worked, so we'll remove the backup of the
      # build number:
      rm -f $PORTCWD/build-nums/${PKGNAME}.orig

      # Back to source toplevel builddir, since cmake may have run in a subdir:
      cd $SLACK_KDE_BUILD_DIR/${kde_module}/$(pkgbase $kde_src)

      mkdir -p $PKG/usr/doc/${PKGNAME}-${MODULAR_PACKAGE_VERSION}
      # Use specific documentation files if available, else use a default set:
      if [ -r $CWD/docs/${PKGNAME} ]; then
        cp -a $(cat $CWD/docs/${PKGNAME}) \
          $PKG/usr/doc/${PKGNAME}-${MODULAR_PACKAGE_VERSION}
      else
        cp -a \
          AUTHORS* CONTRIBUTING* COPYING* HACKING* \
          INSTALL* MAINTAINERS README* NEWS* TODO* \
          $PKG/usr/doc/${PKGNAME}-${MODULAR_PACKAGE_VERSION}
          # If there's a ChangeLog, installing at least part of the recent
          # history is useful, but don't let it get totally out of control:
          changelogliposuction ChangeLog $PKGNAME ${MODULAR_PACKAGE_VERSION}
      fi

      # Get rid of zero-length junk files:
      find $PKG/usr/doc/${PKGNAME}-$MODULAR_PACKAGE_VERSION -type f -size 0 -exec rm --verbose "{}" \;
      rmdir --verbose $PKG/usr/doc/${PKGNAME}-$MODULAR_PACKAGE_VERSION 2> /dev/null

      # If there's any special post-install things to do, do them:
      if [ -r $CWD/post-install/${PKGNAME}.post-install ]; then
        . $CWD/post-install/${PKGNAME}.post-install
      fi

      # If there are Slackware ARM specific post-install things, do them:
      if [ -r $PORTCWD/post-install/${PKGNAME}.post-install ]; then
        . $PORTCWD/post-install/${PKGNAME}.post-install
      fi

      # If this package requires some doinst.sh material, add it here:
      if [ -r $CWD/doinst.sh/${PKGNAME} ]; then
        mkdir -p $PKG/install
        cat $CWD/doinst.sh/${PKGNAME} \
          | sed -e "s#usr/lib#usr/lib${LIBDIRSUFFIX}#g" \
          >> $PKG/install/doinst.sh
      fi

      # If this is a modular package, build it here:
      if [ -d $SLACK_KDE_BUILD_DIR/${kde_module}/package-$PKGNAME ]; then
        cd $PKG

        slackstripall   # strip all .a archives and all ELFs
        slackgzpages -i # compress man & info pages and delete usr/info/dir
        slackslack      # chown -R root:root, chmod -R og-w, slackchown, slack644docs
        no_usr_share_doc

        mkdir -p $PKG/install
        if [ -r $CWD/slack-desc/${PKGNAME} ]; then
          cat $CWD/slack-desc/${PKGNAME} > $PKG/install/slack-desc
        else
          touch $PKG/install/slack-desc-missing
        fi

#        if [ -r $CWD/build/${PKGNAME} ]; then
#          MODBUILD=$(cat $CWD/build/${PKGNAME})
        # Look in the port arch's source dir for a build number for this package:
        if [ -r $PORTCWD/build-nums/${PKGNAME} ]; then
           source $PORTCWD/build-nums/${PKGNAME}
        else
           MODBUILD=$BUILD  ## use the version set in the "arm/build" script.
        fi

        if [ -r $CWD/makepkg/${PKGNAME} ]; then
           # We need to make tgz packages for Slackware ARM because it takes a lot
           # longer to decompress .txz on ARM.
           #sed -e 's?.txz?.tgz?g' $CWD/makepkg/${PKGNAME} > ${SLACK_KDE_BUILD_DIR}/${PKGNAME}.makepkg
           #echo "**** Executing custom makepkg script: $CWD/makepkg/${PKGNAME} ******"
           #BUILD=$MODBUILD . ${SLACK_KDE_BUILD_DIR}/${PKGNAME}.makepkg
           BUILD=$MODBUILD . $CWD/makepkg/${PKGNAME}
           # So we used a special 'makepkg' which means that we must move the new package from the
           # temp dir location back into the main package store:
           # Wipe the existing packages from the package tree (Slackware ARM is backed up - we don't
           # create packages in /tmp and move them manually):

           # Wipe the existing packages from the package tree (Slackware ARM is backed up - we don't
           # create packages in /tmp and move them manually).
           # This external helper caters for packages who share the same package name prefix.
           #
           # rm -fv $PKGSTORE/$PKGSERIES/$( short_package_name $PKGNAME )-*.{txt,t?z,asc}
           ( PKGNAM=$( short_package_name $PKGNAME ) /usr/share/slackdev/slackwipepkg )
           mv -fv ${SLACK_KDE_BUILD_DIR}/${kde_module}/${PKGNAME}-$(echo $MODULAR_PACKAGE_VERSION |tr - _)-${PKGARCH}-${MODBUILD}.t?z $PKGSTORE/$PKGSERIES/
        else
           echo "*** Building package using regular process ***"
           # Build the package:
           ( export MODULAR_PACKAGE_VERSION="$( echo $MODULAR_PACKAGE_VERSION | sed 's?-?_?g' )"
             export SLACKPACKAGE=$PKGNAME-${MODULAR_PACKAGE_VERSION}-$PKGARCH-${MODBUILD}.txz
             export PKGNAM=$PKGNAME # the Slackware ARM makepackage wrapper uses this particular variable name for the package file
             slackmp )
        fi
        # We will continue with the fresh packages installed:
        upgradepkg --install-new --reinstall $PKGSTORE/$PKGSERIES/${PKGNAME}-$(echo $MODULAR_PACKAGE_VERSION |tr - _)-${PKGARCH}-${MODBUILD}.t?z
        # Keep MIME database current:
        /usr/bin/update-mime-database /usr/share/mime 1>/dev/null 2>/dev/null &
      fi

      # Reset $PKG to assume we're building the whole source dir:
      PKG=${SLACK_KDE_BUILD_DIR}/${kde_module}/package-${kde_module}

    done

    # At this point, we have left the loop to build modular packages.
    # We might need to build a package for the "<kde_module>", but to
    # avoid needlessly repacking if there happens to be a package with
    # the same name as "<kde_module>", we'll do some checks first.

    # If every package listed in modules/"<kde_module>" is also listed
    # in the modularize file, then there's no need to make a package
    # for "<kde_module>":
    echo
    echo "Searching for packages in ${kde_module} that were not built modular:"
    cat $CWD/modules/${kde_module} | grep -v "^#" | grep -v -w "^" | while read checkpackage ; do
      if ! grep -wq "^$checkpackage" ${CWD}/modularize ; then
        # Non-modular package found, so we'll have to build the package below.
        # It might already have been built once, but in that case it is likely
        # that more things have been added to the package directory since then.
        echo "Found non-modular package $checkpackage."
        exit 99
      fi
    done

    # Exit if everything in "<kde_module>" was built modular:
    if [ ! $? = 99 ]; then
      echo "No non-modular components found in ${kde_module}."
      echo "Not building catch-all package for ${kde_module}."
      echo
      return
    fi

    # If there's no /usr directory in the "<kde_module>" package directory,
    # then skip it.  There's nothing present worth packing up.
    if [ ! -d ${SLACK_KDE_BUILD_DIR}/${kde_module}/package-${kde_module}/usr ]; then
      echo "No /usr directory found in package-${kde_module}."
      echo "Not building catch-all package for ${kde_module}."
      echo
      return
    fi

    # Build a "<kde_module>" package for anything that wasn't built modular:
    # It's safer to consider these to have binaries in them. ;-)

    # Put up a bit of a black-box warning, in case this was a mistake where
    # something was meant to be listed in the modularize file and wasn't:
    echo
    echo "**************************************************************************"
    echo "* Building combined package for non-modular parts of ${kde_module}"
    echo "**************************************************************************"
    echo

    PKGARCH=$ARCH
    cd $PKG

    slackstripall   # strip all .a archives and all ELFs
    slackgzpages -i # compress man & info pages and delete usr/info/dir
    slackslack      # chown -R root:root, chmod -R og-w, slackchown, slack644docs
    no_usr_share_doc

    # If there are post-install things to do for the combined package,
    # we do them here.  This could be used for things like making a
    # VERSION number for a combined package.  :-)
    if [ -r $CWD/post-install/${kde_module}.post-install ]; then
      . $CWD/post-install/${kde_module}.post-install
    fi

    # If there are Slackware ARM specific post-install things, do them:
    if [ -r $PORTCWD/post-install/${PKGNAME}.post-install ]; then
      . $PORTCWD/post-install/${PKGNAME}.post-install
    fi

    mkdir -p $PKG/install
    if [ -r $CWD/slack-desc/${kde_module} ]; then
      cat $CWD/slack-desc/${kde_module} > $PKG/install/slack-desc
    else
      touch $PKG/install/slack-desc-missing
    fi
    if [ -r $CWD/doinst.sh/${kde_module} ]; then
      cat $CWD/doinst.sh/${kde_module} \
        | sed -e "s#usr/lib#usr/lib${LIBDIRSUFFIX}#g" \
        >> $PKG/install/doinst.sh
    fi
#    if [ -r $CWD/build/${kde_module} ]; then
#      SRCDIRBUILD=$(cat $CWD/build/${kde_module})
    # We only care about the Slackware ARM build numbers since the distribution is
    # maintained independentley.
    if [ -r $PORTCWD/build-nums/${kde_module} ]; then
      source $PORTCWD/build-nums/${kde_module}
      SRCDIRBUILD=$MODBUILD ## it's not a 'modular' piece of KDE, but we'll use the same variable since it's functionally the same thing.
                            ## MODBUILD will be set inside the file we just sourced above.
    else
      SRCDIRBUILD=$BUILD # take it from the arm/build script:
    fi
    if [ -r $CWD/makepkg/${kde_module} ]; then
       echo "**** Executing custom makepkg script: $CWD/makepkg/${PKGNAME} ****"
       # We need to make tgz packages for Slackware ARM because it takes a lot
       # longer to decompress .txz on ARM.
       #sed -e 's?.txz?.tgz?g' $CWD/makepkg/${PKGNAME} > ${SLACK_KDE_BUILD_DIR}/${PKGNAME}.makepkg
       #BUILD=$SRCDIRBUILD . ${SLACK_KDE_BUILD_DIR}/${PKGNAME}.makepkg
       BUILD=$SRCDIRBUILD . $CWD/makepkg/${kde_module}
       # So we used a special 'makepkg' which means that we must move the new package from the
       # temp dir location back into the main package store:

       # Wipe the existing packages from the package tree (Slackware ARM is backed up - we don't
       # create packages in /tmp and move them manually).
       # This external helper caters for packages who share the same package name prefix.
       #
       # rm -fv $PKGSTORE/$PKGSERIES/$( short_package_name $PKGNAME )-*.{txt,t?z,asc}
       ( PKGNAM=$( short_package_name $PKGNAME ) /usr/share/slackdev/slackwipepkg )
       mv -fv ${SLACK_KDE_BUILD_DIR}/${kde_module}/${PKGNAME}-$(echo $VERSION |tr - _)-${PKGARCH}-${SRCDIRBUILD}.t?z $PKGSTORE/$PKGSERIES/
    else
       # Create the package using Slackware ARM's library which takes care of removing
       # the previous versions from the 'slackware' package directory:
       echo "*** Building package using regular process ***"
       # Build the package:
        ( export VERSION="$( echo $VERSION | sed 's?-?_?g' )"
          export SLACKPACKAGE=${kde_module}-${VERSION}-$PKGARCH-${SRCDIRBUILD}.txz
          export PKGNAM=${kde_module} # the Slackware ARM makepackage wrapper uses this particular variable name for the package file
          slackmp )
     # /sbin/makepkg -l y -c n ${SLACK_KDE_BUILD_DIR}/${kde_module}/${kde_module}-$(echo $VERSION |tr - _)-${PKGARCH}-${SRCDIRBUILD}.txz
    fi
    # We will continue with the fresh packages installed:
#    upgradepkg --install-new --reinstall ${SLACK_KDE_BUILD_DIR}/${kde_module}/${kde_module}-${VERSION}-${PKGARCH}-${SRCDIRBUILD}.txz
    upgradepkg --install-new --reinstall $PKGSTORE/$PKGSERIES/${kde_module}-$(echo $VERSION |tr - _)-${PKGARCH}-${SRCDIRBUILD}.t?z
    # Keep MIME database current:
    /usr/bin/update-mime-database /usr/share/mime 1>/dev/null 2>/dev/null &
  )
}

# Process the module queue. Format is:
# module[:subpackage[,subpackage]] [module...]
deterministic_build() {
  RET=0
  for ENTRY in $1 ; do
    KDE_MOD=$(echo "$ENTRY": | cut -f1 -d:)
    KDE_PKGS=$(echo "$ENTRY": | cut -f2 -d:)

    if [ -z "$KDE_PKGS" ]; then
      build_mod_pkg $KDE_MOD
      let RET=$RET+$?
    else
      for KDE_PKG in $(echo $KDE_PKGS |tr ',' ' ') ; do
        build_mod_pkg $KDE_MOD $KDE_PKG
        let RET=$RET+$?
      done
    fi
  done

  return $RET
}


#######################################################################################

# Import the build configuration options for as far as they are not already set:
[ -r $CWD/KDE.options ] && . $CWD/KDE.options

# Slackware ARM modification:
# This file overwrites any needed variables:
[ -r $PORTCWD/KDE.options ] && . $PORTCWD/KDE.options

# This avoids compiling a version number into KDE's .la files:
QTDIR=/usr/lib${LIBDIRSUFFIX}/qt ; export QTDIR

# Get the kde environment variables
[ -d $CWD/post-install/kdebase ] && eval $(sed -e "s#/lib#/lib${LIBDIRSUFFIX}#" $CWD/post-install/kdebase/profile.d/kde.sh)

# Where we are going to do all the hard labour:
SLACK_KDE_BUILD_DIR=$TMPBUILD/kde-build
mkdir -p $SLACK_KDE_BUILD_DIR

# Yes, we know kde-workspace is built twice.  kdebase needs the
#   plasma bits from it, and then we build it again for good measure...
# Same goes for kdelibs (at least during KDE 4.8.x) kdeutils:ksecrets needs
#   kdelibs and then kdelibs needs a rebuild to pick up ksecretservice
#   (this will no longer be required in KDE 4.9).
# And kde-baseapps is rebuilt after kdewebdev because it can then pickup
#   libtidy and enable the Konqueror validators plugin to validate HTML.
KDEMODS=" \
  kdelibs \
  kdebase:nepomuk-core \
  kdepimlibs \
  kdebase \
  kdesdk \
  extragear:libkscreen \
  kdegraphics \
  kdebindings \
  kdebase:kde-workspace \
  kdeaccessibility \
  kdeutils \
  kdelibs \
  kdemultimedia \
  extragear:libktorrent \
  kdenetwork \
  oxygen-icons \
  kdeadmin \
  kdeartwork \
  kdegames \
  kdetoys \
  kdepim \
  kdepim-runtime \
  kdenetwork:kopete \
  \
       kdeedu \
  \
  kdewebdev \
  kdebase:kde-baseapps \
  kdeplasma-addons \
  polkit-kde \
  extragear \
  "

# kdeedu goes in the space above.  Won't build atm... trying for KDE 4.14.5...
# which is why it's indented differently.
#  kdeedu \

# Allow for specification of individual packages to be built:
if [ -z "$1" ]; then
  MODQUEUE=$KDEMODS
else
  MODQUEUE="$*"
fi

# If you are using 'arm/build' to build KDE for the first time (perhaps bootstrapping
# or doing a full version upgrade), you can uncomment the line below to avoid incrementing
# the build number during the successive passes of a few of the core packages.
# You'd still need to ensure that you manually updated the build number files though
# and perhaps (if everything is an upgrade) just removed those files so that they can be
# re-created with the new version numbers automatically.
#
#export MODBUILDNOBUMP=Yes
#

# And finally, start working!
for module in \
  $MODQUEUE ;
do
  echo "SlackBuild processing module '$module'"
  deterministic_build $module
  if [ $? = 0 ]; then
    # Move the created packages up into the KDE build directory:
    # ( The packages are initially created in the right place, so no need on Slackware ARM):
    # mv -fv ${SLACK_KDE_BUILD_DIR}/$(echo $module |cut -f1 -d:)/*.t?z $PKGSTORE/$PKGSERIES/
    if [ "$CLEANUP" = "yes" -o "$CLEANUP" = "YES" ]; then
      # Clean out package and build directories:
      rm -rf ${SLACK_KDE_BUILD_DIR}/$(echo $module |cut -f1 -d:)
    fi
  else
    echo "${module} failed to build."
    exit 1
  fi
  cd - ;
done

# EOF
