#!/bin/bash
set +o posix

#
# Script : slackwarearm-current/source/x/x11/indibuild
# Purpose: Build modular X.org packages, handling build numbers
#          and X.org section types (app/driver/util) automatically.
# by Stuart Winter <mozes@slackware.com>
#
# Copyright 2008-2017  Stuart Winter, Surrey, England.
# All rights reserved.
#
# Redistribution and use of this script, with or without modification, is
# permitted provided that the following conditions are met:
#
# 1. Redistributions of this script must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#
#  THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
#  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
#  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO
#  EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
#  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
#  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
#  OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
#  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
#  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
#  ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#
# Building individual packages
# -----------------------------
# This script aids with building, unattended, the individual components.
# Before running this script, be sure to wipe the existing packages from the
# 'slackware/x' directory.  This helps determine if any of the builds failed/
# if there packages missing.
# It's a bit clunky, but we love it :)
#
# Build numbers
# -------------
# You can set specific build numbers by creating the
# package name inside build-nums dir:
# echo 2 > build-nums/xinit
#
# The way build numbers are handled in Slackware ARM is that
# when building individual components (which is always the way
# unless you're starting a port from scratch), you:
#
# 1.  Check if there's a file with the package base name inside the 'build-nums' directory
#     and create one if there isn't.
#
# 2.  Adjust the build number -- either increasing it if it's a package rebuild,
#     or resetting it to '1' if it's a version update.
#
# The reason for this is that Slackware build numbers often differ from Slackware ARM
# since it takes a while to catch up, and there may have already been several
# rebuilds in Slackware before we even start looking at rebuilding the package.
#
# When dealing with an Xorg update in Slackware, the easiest way to do it (without
# running the entire X11.SlackBuild), is to:
# - Filter only the x updates from the ChangeLog entries
# - Grep "Removed" note down which exist for ARM, and paste those .t?z file names into
#   Slackware ARM's changelog.
# - Grep "Rebuilt" and add those to this script
# - Grep "Added" and add those to the "Upgraded" (since the script handles them the same)
# - Grep "Upgraded", as below:
# cat /tmp/f | grep Upgraded | sed 's?+x/??g' | cut -d: -f1 | rev | cut -d- -f4- | rev | while read updpkg ; do echo "$updpkg \\" ; done
# The first time, run this script WITHOUT updating build numbers - just to get everything
# upgraded and on the live filesystem.
# Run again, without updating version numbers to ensure everything links against each other
# For the Rebuilt packages, build those by supplying the "R" option to the "build" function
# For Upgraded packages, build those with the U option.
#######################################################################################
#
# pkg-config --libs --cflags glib-2.0
#
#

source /usr/share/slackdev/buildkit.sh
ORIGCWD=$PWD

mkdir -vpm755 $ORIGCWD/build-logs

##############################################################
#
# Syntax:
#    build <pkgname> [U|R]
# U=Package version upgrade, so the .t?z will be at build '1'
#   do this for NEW packages also
# R=Package rebuild, so the .t?z will be build+1
#
# If you exclude R or U then the build number is unmodified.
#
function build () {

 unset MODBUILDNOBUMP ## allow build number to be incremented.
 INDIPKG=$1

 echo "*********************************"
 echo "***** Working on modular package: ${INDIPKG} *****"
 echo "*********************************"

 # If it's an upgrade then we delete any build number, otherwise if it's a rebuild,
 # we'd want to update the build number but I'll leave that until later :)
 # The process-x11-changelog script outputs "Added" as "A", but in fact Added is the same
 # as upgraded since all it means is that the build is =1.  There are seperate release processing
 # scripts that determine whether a package was added, based on the tag file contents.
 if [ "$2" = "U" -o "$2" = "A" ]; then
    echo "This is tagged as a package UPGRADE/NEW PACKAGE, set build: 1."
    echo "MODBUILD=1" > $ORIGCWD/build-nums/$INDIPKG
  elif [ "$2" = "R" ]; then
    # It's a rebuild & increment the build number:
    if [ -s $ORIGCWD/build-nums/$INDIPKG ]; then
       source $ORIGCWD/build-nums/$INDIPKG
       let MODBUILD++
       echo "Tagged as a rebuild - will be build: $MODBUILD"
       # This is handled in x11.SlackBuild now:
       # but ensure that MODBUILDNOBUMP is unset in arm/build:
       # (it should always be unless we're bootstrapping a new X)
#       echo "_PKGVER=${_PKGVER}" > $ORIGCWD/build-nums/$INDIPKG
#       echo "MODBUILD=$MODBUILD" >> $ORIGCWD/build-nums/$INDIPKG
      else
       # x11.SlackBuild assumes a build number of what is set in "arm/build" if there isn't a
       # build stamp file for a particular modular package.
       # but if we've not already got a build number, but got a package then we need
       # to assume that this is going to be the 2nd build.
       # This is because we only started creating build stamp files much later in the
       # evolution of X11 packaging for Slackware ARM.
       # There's no package version included at this point but that does not
       # matter - it'll be dealt with in x11.SlackBuild.
       echo "MODBUILD=2" > $ORIGCWD/build-nums/$INDIPKG
       echo "Tagged as a rebuild but has no build stamp file - setting as build: 2"
    fi
  # If we don't specify either U or R, then we leave the build number alone
  # since we may be just making some test packages prior to a public tree push.
  # Build numbers are never updated when the build of a particular package version
  # hasn't ever been pushed publically.
  elif [ -z "$2" ]; then
     export MODBUILDNOBUMP=Yes
     echo "*** Package rebuild without build increment ***"
  fi

 # Determine the section of X where we'll find the source:
 # the head -n1 is because *xcb-util* returns the 'x11/src/xvb' dir basename for all of the
 # other xcb-util-* archives.
 ~/armedslack/dbuild $( basename $( find $SLACKSOURCE/x/x11/src -name "*$INDIPKG*z" -printf "%h\n" | head -n1 )) $INDIPKG 2>&1 | tee $ORIGCWD/build-logs/$INDIPKG.log
 #
 # For /patches - we don't use distcc on stable machines:
 #./arm/build $( basename $( find $SLACKSOURCE/x/x11/src -name "*$INDIPKG*z" -printf "%h\n" | head -n1 )) $INDIPKG 2>&1 | tee $ORIGCWD/build-logs/$INDIPKG.log

}


# We rebuild things over and over to get them all holding hands.  Obviously this doesn't
# guarantee hand holding since the build list remains static, but those who refuse can be
# cajoled into it later if need be.
#
function passes_build() {
# Don't build with DRI:
# No point. I thought it'd help with the KDE crash but it doesn't.
#sed -i 's?--with-dri-driver-path=.*?\\?g' $SLACKSOURCE/x/x11/configure/xorg-server
#
for (( pass=1; pass <=3 ; pass++ )); do
  echo "***********************************"
  echo "***** x11 indibuild PASS $pass    *****"
  echo "***********************************"

  sleep 3

for i in \
  \
 "xkeyboard-config U" \
 "xdm R" \
  \
  \
 ; do

  # Building in patches? This saves editing lots in x11.SlackBuild, and x11 patches are
  # rare and the build system is complicated, so a hack will suffice.
  # Nasty hack but gets the job done.
  #( cd ~/armedslack/slackware64-14.2/patches/source/
  #   mkdir -p x ; cd x
  #   rm -f x11
  #   ln -vfs ../$i x11 )


  # Running independently (not via r2b (the Slackware ARM build system)) and on final pass,
  # or running through r2b and on both indibuild & r2b's final pass:
  #
  # Until the final pass we only care about getting the package compiled and installed
  # on the system: the Slackware binary package build numbers (1=added/upgraded or >1 = rebuilt)
  # get set on the final pass.
  #
  if [ -z "$R2BCURRENTPASS" -a $pass = 3 ] || [ "$R2BFINALPASS" = "1" -a $pass = 3 ]; then
     BUILDTAG=${i##*\ } # Take tag supplied with the package name from the list above
    else
     unset BUILDTAG ## Build version will remain untouched until the final pass of either r2b and/or indibuild.
  fi

  echo "Package: ${i%%\ *}, Final tag: ${i##*\ } [ current pass tag=${BUILDTAG:-none, still building} ]"

  build ${i%%\ *} ${BUILDTAG}
done

# end "pass"
done
}

#########################################################################################
# Slackware ARM packages
# These packages aren't included in Slackware either because they aren't needed
# or are found not to work.
#
# They're needed on the ARM platform though.
#########################################################################################
#
# This is cheating - a dirty work around to avoid hacking x11.SlackBuild some more.
# fbdev is removed from Slackware since it causes failures when a machine has no xorg.conf, but
# we need it for ARMedslack - and it works with or without an xorg.conf.
#

# Update xorg server and some other bits first prior to rebuilding the ARM x11 drivers
# against it.
#passes_build
#exit

###################################
# Package: driver/xf86-video-fbdev
###################################
#
# Hack.  This should really be patched by now.
#cp -fav $ORIGCWD/EXCLUDE/mibstore.h /usr/X11/include/
## Remove it from the package black list, allowing it to build:
#sed -i 's?xf86-video-fbdev??g' $SLACKSOURCE/x/x11/package-blacklist || exit 1
# Install our local copy into the Slackware tree because this is easier than modifying
# the x11.SlackBuild to find the source in our local tree.  It's a little hacky I agree but
# for one package, I adjust my standards ;-)
#cp -favv $ORIGCWD/src/driver/xf86-video-fbdev*  $SLACKSOURCE/x/x11/src/driver/ || exit 1
#build xf86-video-fbdev U
#build xf86-video-fbdev R
#build xf86-video-fbdev # without build increment
#rm -fv $SLACKSOURCE/x/x11/src/driver/xf86-video-fbdev*
#exit

# OpenTegra
#cp -favv $ORIGCWD/slack-desc/x*-opentegra $SLACKSOURCE/x/x11/slack-desc/  || exit 1
#cp -favv $ORIGCWD/src/driver/xf86-video-opentegra*  $SLACKSOURCE/x/x11/src/driver/ || exit 1
#build xf86-video-opentegra U
#build xf86-video-opentegra R
#build xf86-video-opentegra # without increment
#exit

# xf86-video-fbturbo
# https://github.com/ssvb/xf86-video-fbturbo/wiki/Installation
#
#cp -favv $ORIGCWD/slack-desc/x*-fbturbo $SLACKSOURCE/x/x11/slack-desc/  || exit 1
#cp -favv $ORIGCWD/src/driver/xf86-video-fbturbo*  $SLACKSOURCE/x/x11/src/driver/ || exit 1
##build xf86-video-fbturbo # without increment
#build xf86-video-fbturbo U
#build xf86-video-fbturbo R
#exit

# ARM SoC
# Patch for glibc-2.20:
#sed -i '/#include <string.h>/a#include <xorg-server.h>' /usr/include/xorg/os.h
#cp -favv $ORIGCWD/slack-desc/x*-armsoc $SLACKSOURCE/x/x11/slack-desc/  || exit 1
#cp -favv $ORIGCWD/src/driver/xf86-video-armsoc-*  $SLACKSOURCE/x/x11/src/driver/ || exit 1
##build xf86-video-armsoc # without increment
##build xf86-video-armsoc U
#build xf86-video-armsoc R
#exit

# OMAP driver - not in use since it segfaults.
#sed -i 's?xf86-video-omap??g' $SLACKSOURCE/x/x11/package-blacklist || exit 1
#cp -favv $ORIGCWD/slack-desc/*omap* $SLACKSOURCE/x/x11/slack-desc/  || exit 1
#cp -favv $ORIGCWD/src/driver/xf86-video-omapfb*  $SLACKSOURCE/x/x11/src/driver/ || exit 1
#build xf86-video-omapfb U
#exit

# Rebuild the modules.  This is useful after an Xorg server update since they often tend to get
# missed.  This should be used in conjunction with the code directly above.
# You may just want to build all of them so adjust the list below accordingly.
# armsoc|xf86-video-fbdev|xf86-video-omapfb|xf86-video-xgi
#
# An rough way to figure out what's has not been updated for a while.
# - Update/rebuild everything as in the x86 change log, then
# ~/tgzstash/x# ls -la *z | grep -v 'Aug.*[0-9][0-9]:[0-9][0-9]'
# In this case I am removing anything that was build in August this year (which is when I did the
# X11 updates).  This means that I can decide whether to rebuild packages without having to increment
# the build number.
#( cd $SLACKSOURCE/x/x11/src/driver
#  ls -1 | rev | cut -d- -f2- | rev | egrep -v 'armsoc|xf86-video-fbdev|xf86-video-omapfb|xf86-video-xgi$' ) | while read drivermodpkg ; do
##    build $drivermodpkg R ## increment build.
#    build $drivermodpkg ## build without incrementing.
#  done
#exit

# Rebuild everything that was built recently, but without incrementing the build number.
# This is useful if X was built in the wrong order, and subsequent updates to other packages
# cause it to break --  'nettle' is a package where an update can break the xorg-server.
# It's good practice to do this after a large package update.
#while read x11pkg ; do
# build $x11pkg
#done< <( find build-nums -mtime -10 -not -name build-nums -printf "%f \\ \n" )
#exit

# We can also determine what's old in X11 that hasn't been built for a while.
# We remove anything that's outside of the X11 tree:
# You paste this output into the for loop below.
# cd ~/tgzstash/x
# find . -not -mtime -10 -name '*.t?z'  |rev | cut -d- -f4- | rev | sed 's?./??g'| while read line ; do
#    if [ ! -d ../../source/x/$line ]; then
#       echo "$line \\"
#    fi
#  done

########################################################################################
# The following packages are both in Slackware x86 & ARM
########################################################################################

# Upgrade a bunch of stuff:
# When upgrading "xorg-server" packages, you only need to rebuild the
# base "xorg-server" - the others "xnest" etc will be built during that run.
# ** Remember to set R(ebuild) or U(pgrade) here!


build xorg-server R

#exit

# This is only for x86:
#build xf86-input-vmmouse R
#exit

